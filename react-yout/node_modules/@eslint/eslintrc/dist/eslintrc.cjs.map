{"version":3,"file":"eslintrc.cjs","sources":["../lib/config-array/ignore-pattern.js","../lib/config-array/extracted-config.js","../lib/config-array/config-array.js","../lib/config-array/config-dependency.js","../lib/config-array/override-tester.js","../lib/config-array/index.js","../lib/shared/config-ops.js","../lib/shared/deprecation-warnings.js","../lib/shared/ajv.js","../conf/config-schema.js","../conf/environments.js","../lib/shared/config-validator.js","../lib/shared/naming.js","../lib/shared/relative-module-resolver.js","../lib/config-array-factory.js","../lib/cascading-config-array-factory.js","../lib/flat-compat.js","../lib/index.js"],"sourcesContent":["/**\n * @fileoverview `IgnorePattern` class.\n *\n * `IgnorePattern` class has the set of glob patterns and the base path.\n *\n * It provides two static methods.\n *\n * - `IgnorePattern.createDefaultIgnore(cwd)`\n *      Create the default predicate function.\n * - `IgnorePattern.createIgnore(ignorePatterns)`\n *      Create the predicate function from multiple `IgnorePattern` objects.\n *\n * It provides two properties and a method.\n *\n * - `patterns`\n *      The glob patterns that ignore to lint.\n * - `basePath`\n *      The base path of the glob patterns. If absolute paths existed in the\n *      glob patterns, those are handled as relative paths to the base path.\n * - `getPatternsRelativeTo(basePath)`\n *      Get `patterns` as modified for a given base path. It modifies the\n *      absolute paths in the patterns as prepending the difference of two base\n *      paths.\n *\n * `ConfigArrayFactory` creates `IgnorePattern` objects when it processes\n * `ignorePatterns` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport assert from \"assert\";\nimport path from \"path\";\nimport ignore from \"ignore\";\nimport debugOrig from \"debug\";\n\nconst debug = debugOrig(\"eslintrc:ignore-pattern\");\n\n/** @typedef {ReturnType<import(\"ignore\").default>} Ignore */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the path to the common ancestor directory of given paths.\n * @param {string[]} sourcePaths The paths to calculate the common ancestor.\n * @returns {string} The path to the common ancestor directory.\n */\nfunction getCommonAncestorPath(sourcePaths) {\n    let result = sourcePaths[0];\n\n    for (let i = 1; i < sourcePaths.length; ++i) {\n        const a = result;\n        const b = sourcePaths[i];\n\n        // Set the shorter one (it's the common ancestor if one includes the other).\n        result = a.length < b.length ? a : b;\n\n        // Set the common ancestor.\n        for (let j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {\n            if (a[j] !== b[j]) {\n                result = a.slice(0, lastSepPos);\n                break;\n            }\n            if (a[j] === path.sep) {\n                lastSepPos = j;\n            }\n        }\n    }\n\n    let resolvedResult = result || path.sep;\n\n    // if Windows common ancestor is root of drive must have trailing slash to be absolute.\n    if (resolvedResult && resolvedResult.endsWith(\":\") && process.platform === \"win32\") {\n        resolvedResult += path.sep;\n    }\n    return resolvedResult;\n}\n\n/**\n * Make relative path.\n * @param {string} from The source path to get relative path.\n * @param {string} to The destination path to get relative path.\n * @returns {string} The relative path.\n */\nfunction relative(from, to) {\n    const relPath = path.relative(from, to);\n\n    if (path.sep === \"/\") {\n        return relPath;\n    }\n    return relPath.split(path.sep).join(\"/\");\n}\n\n/**\n * Get the trailing slash if existed.\n * @param {string} filePath The path to check.\n * @returns {string} The trailing slash if existed.\n */\nfunction dirSuffix(filePath) {\n    const isDir = (\n        filePath.endsWith(path.sep) ||\n        (process.platform === \"win32\" && filePath.endsWith(\"/\"))\n    );\n\n    return isDir ? \"/\" : \"\";\n}\n\nconst DefaultPatterns = Object.freeze([\"/**/node_modules/*\"]);\nconst DotPatterns = Object.freeze([\".*\", \"!.eslintrc.*\", \"!../\"]);\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nclass IgnorePattern {\n\n    /**\n     * The default patterns.\n     * @type {string[]}\n     */\n    static get DefaultPatterns() {\n        return DefaultPatterns;\n    }\n\n    /**\n     * Create the default predicate function.\n     * @param {string} cwd The current working directory.\n     * @returns {((filePath:string, dot:boolean) => boolean) & {basePath:string; patterns:string[]}}\n     * The preficate function.\n     * The first argument is an absolute path that is checked.\n     * The second argument is the flag to not ignore dotfiles.\n     * If the predicate function returned `true`, it means the path should be ignored.\n     */\n    static createDefaultIgnore(cwd) {\n        return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);\n    }\n\n    /**\n     * Create the predicate function from multiple `IgnorePattern` objects.\n     * @param {IgnorePattern[]} ignorePatterns The list of ignore patterns.\n     * @returns {((filePath:string, dot?:boolean) => boolean) & {basePath:string; patterns:string[]}}\n     * The preficate function.\n     * The first argument is an absolute path that is checked.\n     * The second argument is the flag to not ignore dotfiles.\n     * If the predicate function returned `true`, it means the path should be ignored.\n     */\n    static createIgnore(ignorePatterns) {\n        debug(\"Create with: %o\", ignorePatterns);\n\n        const basePath = getCommonAncestorPath(ignorePatterns.map(p => p.basePath));\n        const patterns = [].concat(\n            ...ignorePatterns.map(p => p.getPatternsRelativeTo(basePath))\n        );\n        const ig = ignore({ allowRelativePaths: true }).add([...DotPatterns, ...patterns]);\n        const dotIg = ignore({ allowRelativePaths: true }).add(patterns);\n\n        debug(\"  processed: %o\", { basePath, patterns });\n\n        return Object.assign(\n            (filePath, dot = false) => {\n                assert(path.isAbsolute(filePath), \"'filePath' should be an absolute path.\");\n                const relPathRaw = relative(basePath, filePath);\n                const relPath = relPathRaw && (relPathRaw + dirSuffix(filePath));\n                const adoptedIg = dot ? dotIg : ig;\n                const result = relPath !== \"\" && adoptedIg.ignores(relPath);\n\n                debug(\"Check\", { filePath, dot, relativePath: relPath, result });\n                return result;\n            },\n            { basePath, patterns }\n        );\n    }\n\n    /**\n     * Initialize a new `IgnorePattern` instance.\n     * @param {string[]} patterns The glob patterns that ignore to lint.\n     * @param {string} basePath The base path of `patterns`.\n     */\n    constructor(patterns, basePath) {\n        assert(path.isAbsolute(basePath), \"'basePath' should be an absolute path.\");\n\n        /**\n         * The glob patterns that ignore to lint.\n         * @type {string[]}\n         */\n        this.patterns = patterns;\n\n        /**\n         * The base path of `patterns`.\n         * @type {string}\n         */\n        this.basePath = basePath;\n\n        /**\n         * If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.\n         *\n         * It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.\n         * It's `false` as-is for `ignorePatterns` property in config files.\n         * @type {boolean}\n         */\n        this.loose = false;\n    }\n\n    /**\n     * Get `patterns` as modified for a given base path. It modifies the\n     * absolute paths in the patterns as prepending the difference of two base\n     * paths.\n     * @param {string} newBasePath The base path.\n     * @returns {string[]} Modifired patterns.\n     */\n    getPatternsRelativeTo(newBasePath) {\n        assert(path.isAbsolute(newBasePath), \"'newBasePath' should be an absolute path.\");\n        const { basePath, loose, patterns } = this;\n\n        if (newBasePath === basePath) {\n            return patterns;\n        }\n        const prefix = `/${relative(newBasePath, basePath)}`;\n\n        return patterns.map(pattern => {\n            const negative = pattern.startsWith(\"!\");\n            const head = negative ? \"!\" : \"\";\n            const body = negative ? pattern.slice(1) : pattern;\n\n            if (body.startsWith(\"/\") || body.startsWith(\"../\")) {\n                return `${head}${prefix}${body}`;\n            }\n            return loose ? pattern : `${head}${prefix}/**/${body}`;\n        });\n    }\n}\n\nexport { IgnorePattern };\n","/**\n * @fileoverview `ExtractedConfig` class.\n *\n * `ExtractedConfig` class expresses a final configuration for a specific file.\n *\n * It provides one method.\n *\n * - `toCompatibleObjectAsConfigFileContent()`\n *      Convert this configuration to the compatible object as the content of\n *      config files. It converts the loaded parser and plugins to strings.\n *      `CLIEngine#getConfigForFile(filePath)` method uses this method.\n *\n * `ConfigArray#extractConfig(filePath)` creates a `ExtractedConfig` instance.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\nimport { IgnorePattern } from \"./ignore-pattern.js\";\n\n// For VSCode intellisense\n/** @typedef {import(\"../../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../../shared/types\").SeverityConf} SeverityConf */\n/** @typedef {import(\"./config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-dependency\").DependentPlugin} DependentPlugin */\n\n/**\n * Check if `xs` starts with `ys`.\n * @template T\n * @param {T[]} xs The array to check.\n * @param {T[]} ys The array that may be the first part of `xs`.\n * @returns {boolean} `true` if `xs` starts with `ys`.\n */\nfunction startsWith(xs, ys) {\n    return xs.length >= ys.length && ys.every((y, i) => y === xs[i]);\n}\n\n/**\n * The class for extracted config data.\n */\nclass ExtractedConfig {\n    constructor() {\n\n        /**\n         * The config name what `noInlineConfig` setting came from.\n         * @type {string}\n         */\n        this.configNameOfNoInlineConfig = \"\";\n\n        /**\n         * Environments.\n         * @type {Record<string, boolean>}\n         */\n        this.env = {};\n\n        /**\n         * Global variables.\n         * @type {Record<string, GlobalConf>}\n         */\n        this.globals = {};\n\n        /**\n         * The glob patterns that ignore to lint.\n         * @type {(((filePath:string, dot?:boolean) => boolean) & { basePath:string; patterns:string[] }) | undefined}\n         */\n        this.ignores = void 0;\n\n        /**\n         * The flag that disables directive comments.\n         * @type {boolean|undefined}\n         */\n        this.noInlineConfig = void 0;\n\n        /**\n         * Parser definition.\n         * @type {DependentParser|null}\n         */\n        this.parser = null;\n\n        /**\n         * Options for the parser.\n         * @type {Object}\n         */\n        this.parserOptions = {};\n\n        /**\n         * Plugin definitions.\n         * @type {Record<string, DependentPlugin>}\n         */\n        this.plugins = {};\n\n        /**\n         * Processor ID.\n         * @type {string|null}\n         */\n        this.processor = null;\n\n        /**\n         * The flag that reports unused `eslint-disable` directive comments.\n         * @type {boolean|undefined}\n         */\n        this.reportUnusedDisableDirectives = void 0;\n\n        /**\n         * Rule settings.\n         * @type {Record<string, [SeverityConf, ...any[]]>}\n         */\n        this.rules = {};\n\n        /**\n         * Shared settings.\n         * @type {Object}\n         */\n        this.settings = {};\n    }\n\n    /**\n     * Convert this config to the compatible object as a config file content.\n     * @returns {ConfigData} The converted object.\n     */\n    toCompatibleObjectAsConfigFileContent() {\n        const {\n            /* eslint-disable no-unused-vars */\n            configNameOfNoInlineConfig: _ignore1,\n            processor: _ignore2,\n            /* eslint-enable no-unused-vars */\n            ignores,\n            ...config\n        } = this;\n\n        config.parser = config.parser && config.parser.filePath;\n        config.plugins = Object.keys(config.plugins).filter(Boolean).reverse();\n        config.ignorePatterns = ignores ? ignores.patterns : [];\n\n        // Strip the default patterns from `ignorePatterns`.\n        if (startsWith(config.ignorePatterns, IgnorePattern.DefaultPatterns)) {\n            config.ignorePatterns =\n                config.ignorePatterns.slice(IgnorePattern.DefaultPatterns.length);\n        }\n\n        return config;\n    }\n}\n\nexport { ExtractedConfig };\n","/**\n * @fileoverview `ConfigArray` class.\n *\n * `ConfigArray` class expresses the full of a configuration. It has the entry\n * config file, base config files that were extended, loaded parsers, and loaded\n * plugins.\n *\n * `ConfigArray` class provides three properties and two methods.\n *\n * - `pluginEnvironments`\n * - `pluginProcessors`\n * - `pluginRules`\n *      The `Map` objects that contain the members of all plugins that this\n *      config array contains. Those map objects don't have mutation methods.\n *      Those keys are the member ID such as `pluginId/memberName`.\n * - `isRoot()`\n *      If `true` then this configuration has `root:true` property.\n * - `extractConfig(filePath)`\n *      Extract the final configuration for a given file. This means merging\n *      every config array element which that `criteria` property matched. The\n *      `filePath` argument must be an absolute path.\n *\n * `ConfigArrayFactory` provides the loading logic of config files.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport { ExtractedConfig } from \"./extracted-config.js\";\nimport { IgnorePattern } from \"./ignore-pattern.js\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"../../shared/types\").Environment} Environment */\n/** @typedef {import(\"../../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../../shared/types\").Rule} Rule */\n/** @typedef {import(\"../../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../../shared/types\").Processor} Processor */\n/** @typedef {import(\"./config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {import(\"./override-tester\")[\"OverrideTester\"]} OverrideTester */\n\n/**\n * @typedef {Object} ConfigArrayElement\n * @property {string} name The name of this config element.\n * @property {string} filePath The path to the source file of this config element.\n * @property {InstanceType<OverrideTester>|null} criteria The tester for the `files` and `excludedFiles` of this config element.\n * @property {Record<string, boolean>|undefined} env The environment settings.\n * @property {Record<string, GlobalConf>|undefined} globals The global variable settings.\n * @property {IgnorePattern|undefined} ignorePattern The ignore patterns.\n * @property {boolean|undefined} noInlineConfig The flag that disables directive comments.\n * @property {DependentParser|undefined} parser The parser loader.\n * @property {Object|undefined} parserOptions The parser options.\n * @property {Record<string, DependentPlugin>|undefined} plugins The plugin loaders.\n * @property {string|undefined} processor The processor name to refer plugin's processor.\n * @property {boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.\n * @property {boolean|undefined} root The flag to express root.\n * @property {Record<string, RuleConf>|undefined} rules The rule settings\n * @property {Object|undefined} settings The shared settings.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The element type.\n */\n\n/**\n * @typedef {Object} ConfigArrayInternalSlots\n * @property {Map<string, ExtractedConfig>} cache The cache to extract configs.\n * @property {ReadonlyMap<string, Environment>|null} envMap The map from environment ID to environment definition.\n * @property {ReadonlyMap<string, Processor>|null} processorMap The map from processor ID to environment definition.\n * @property {ReadonlyMap<string, Rule>|null} ruleMap The map from rule ID to rule definition.\n */\n\n/** @type {WeakMap<ConfigArray, ConfigArrayInternalSlots>} */\nconst internalSlotsMap = new class extends WeakMap {\n    get(key) {\n        let value = super.get(key);\n\n        if (!value) {\n            value = {\n                cache: new Map(),\n                envMap: null,\n                processorMap: null,\n                ruleMap: null\n            };\n            super.set(key, value);\n        }\n\n        return value;\n    }\n}();\n\n/**\n * Get the indices which are matched to a given file.\n * @param {ConfigArrayElement[]} elements The elements.\n * @param {string} filePath The path to a target file.\n * @returns {number[]} The indices.\n */\nfunction getMatchedIndices(elements, filePath) {\n    const indices = [];\n\n    for (let i = elements.length - 1; i >= 0; --i) {\n        const element = elements[i];\n\n        if (!element.criteria || (filePath && element.criteria.test(filePath))) {\n            indices.push(i);\n        }\n    }\n\n    return indices;\n}\n\n/**\n * Check if a value is a non-null object.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(x) {\n    return typeof x === \"object\" && x !== null;\n}\n\n/**\n * Merge two objects.\n *\n * Assign every property values of `y` to `x` if `x` doesn't have the property.\n * If `x`'s property value is an object, it does recursive.\n * @param {Object} target The destination to merge\n * @param {Object|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeWithoutOverwrite(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n\n        if (isNonNullObject(target[key])) {\n            mergeWithoutOverwrite(target[key], source[key]);\n        } else if (target[key] === void 0) {\n            if (isNonNullObject(source[key])) {\n                target[key] = Array.isArray(source[key]) ? [] : {};\n                mergeWithoutOverwrite(target[key], source[key]);\n            } else if (source[key] !== void 0) {\n                target[key] = source[key];\n            }\n        }\n    }\n}\n\n/**\n * The error for plugin conflicts.\n */\nclass PluginConflictError extends Error {\n\n    /**\n     * Initialize this error object.\n     * @param {string} pluginId The plugin ID.\n     * @param {{filePath:string, importerName:string}[]} plugins The resolved plugins.\n     */\n    constructor(pluginId, plugins) {\n        super(`Plugin \"${pluginId}\" was conflicted between ${plugins.map(p => `\"${p.importerName}\"`).join(\" and \")}.`);\n        this.messageTemplate = \"plugin-conflict\";\n        this.messageData = { pluginId, plugins };\n    }\n}\n\n/**\n * Merge plugins.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, DependentPlugin>} target The destination to merge\n * @param {Record<string, DependentPlugin>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergePlugins(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n        const targetValue = target[key];\n        const sourceValue = source[key];\n\n        // Adopt the plugin which was found at first.\n        if (targetValue === void 0) {\n            if (sourceValue.error) {\n                throw sourceValue.error;\n            }\n            target[key] = sourceValue;\n        } else if (sourceValue.filePath !== targetValue.filePath) {\n            throw new PluginConflictError(key, [\n                {\n                    filePath: targetValue.filePath,\n                    importerName: targetValue.importerName\n                },\n                {\n                    filePath: sourceValue.filePath,\n                    importerName: sourceValue.importerName\n                }\n            ]);\n        }\n    }\n}\n\n/**\n * Merge rule configs.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, Array>} target The destination to merge\n * @param {Record<string, RuleConf>|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeRuleConfigs(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n        const targetDef = target[key];\n        const sourceDef = source[key];\n\n        // Adopt the rule config which was found at first.\n        if (targetDef === void 0) {\n            if (Array.isArray(sourceDef)) {\n                target[key] = [...sourceDef];\n            } else {\n                target[key] = [sourceDef];\n            }\n\n        /*\n         * If the first found rule config is severity only and the current rule\n         * config has options, merge the severity and the options.\n         */\n        } else if (\n            targetDef.length === 1 &&\n            Array.isArray(sourceDef) &&\n            sourceDef.length >= 2\n        ) {\n            targetDef.push(...sourceDef.slice(1));\n        }\n    }\n}\n\n/**\n * Create the extracted config.\n * @param {ConfigArray} instance The config elements.\n * @param {number[]} indices The indices to use.\n * @returns {ExtractedConfig} The extracted config.\n */\nfunction createConfig(instance, indices) {\n    const config = new ExtractedConfig();\n    const ignorePatterns = [];\n\n    // Merge elements.\n    for (const index of indices) {\n        const element = instance[index];\n\n        // Adopt the parser which was found at first.\n        if (!config.parser && element.parser) {\n            if (element.parser.error) {\n                throw element.parser.error;\n            }\n            config.parser = element.parser;\n        }\n\n        // Adopt the processor which was found at first.\n        if (!config.processor && element.processor) {\n            config.processor = element.processor;\n        }\n\n        // Adopt the noInlineConfig which was found at first.\n        if (config.noInlineConfig === void 0 && element.noInlineConfig !== void 0) {\n            config.noInlineConfig = element.noInlineConfig;\n            config.configNameOfNoInlineConfig = element.name;\n        }\n\n        // Adopt the reportUnusedDisableDirectives which was found at first.\n        if (config.reportUnusedDisableDirectives === void 0 && element.reportUnusedDisableDirectives !== void 0) {\n            config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;\n        }\n\n        // Collect ignorePatterns\n        if (element.ignorePattern) {\n            ignorePatterns.push(element.ignorePattern);\n        }\n\n        // Merge others.\n        mergeWithoutOverwrite(config.env, element.env);\n        mergeWithoutOverwrite(config.globals, element.globals);\n        mergeWithoutOverwrite(config.parserOptions, element.parserOptions);\n        mergeWithoutOverwrite(config.settings, element.settings);\n        mergePlugins(config.plugins, element.plugins);\n        mergeRuleConfigs(config.rules, element.rules);\n    }\n\n    // Create the predicate function for ignore patterns.\n    if (ignorePatterns.length > 0) {\n        config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());\n    }\n\n    return config;\n}\n\n/**\n * Collect definitions.\n * @template T, U\n * @param {string} pluginId The plugin ID for prefix.\n * @param {Record<string,T>} defs The definitions to collect.\n * @param {Map<string, U>} map The map to output.\n * @param {function(T): U} [normalize] The normalize function for each value.\n * @returns {void}\n */\nfunction collect(pluginId, defs, map, normalize) {\n    if (defs) {\n        const prefix = pluginId && `${pluginId}/`;\n\n        for (const [key, value] of Object.entries(defs)) {\n            map.set(\n                `${prefix}${key}`,\n                normalize ? normalize(value) : value\n            );\n        }\n    }\n}\n\n/**\n * Normalize a rule definition.\n * @param {Function|Rule} rule The rule definition to normalize.\n * @returns {Rule} The normalized rule definition.\n */\nfunction normalizePluginRule(rule) {\n    return typeof rule === \"function\" ? { create: rule } : rule;\n}\n\n/**\n * Delete the mutation methods from a given map.\n * @param {Map<any, any>} map The map object to delete.\n * @returns {void}\n */\nfunction deleteMutationMethods(map) {\n    Object.defineProperties(map, {\n        clear: { configurable: true, value: void 0 },\n        delete: { configurable: true, value: void 0 },\n        set: { configurable: true, value: void 0 }\n    });\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArrayElement[]} elements The config elements.\n * @param {ConfigArrayInternalSlots} slots The internal slots.\n * @returns {void}\n */\nfunction initPluginMemberMaps(elements, slots) {\n    const processed = new Set();\n\n    slots.envMap = new Map();\n    slots.processorMap = new Map();\n    slots.ruleMap = new Map();\n\n    for (const element of elements) {\n        if (!element.plugins) {\n            continue;\n        }\n\n        for (const [pluginId, value] of Object.entries(element.plugins)) {\n            const plugin = value.definition;\n\n            if (!plugin || processed.has(pluginId)) {\n                continue;\n            }\n            processed.add(pluginId);\n\n            collect(pluginId, plugin.environments, slots.envMap);\n            collect(pluginId, plugin.processors, slots.processorMap);\n            collect(pluginId, plugin.rules, slots.ruleMap, normalizePluginRule);\n        }\n    }\n\n    deleteMutationMethods(slots.envMap);\n    deleteMutationMethods(slots.processorMap);\n    deleteMutationMethods(slots.ruleMap);\n}\n\n/**\n * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.\n * @param {ConfigArray} instance The config elements.\n * @returns {ConfigArrayInternalSlots} The extracted config.\n */\nfunction ensurePluginMemberMaps(instance) {\n    const slots = internalSlotsMap.get(instance);\n\n    if (!slots.ruleMap) {\n        initPluginMemberMaps(instance, slots);\n    }\n\n    return slots;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The Config Array.\n *\n * `ConfigArray` instance contains all settings, parsers, and plugins.\n * You need to call `ConfigArray#extractConfig(filePath)` method in order to\n * extract, merge and get only the config data which is related to an arbitrary\n * file.\n * @extends {Array<ConfigArrayElement>}\n */\nclass ConfigArray extends Array {\n\n    /**\n     * Get the plugin environments.\n     * The returned map cannot be mutated.\n     * @type {ReadonlyMap<string, Environment>} The plugin environments.\n     */\n    get pluginEnvironments() {\n        return ensurePluginMemberMaps(this).envMap;\n    }\n\n    /**\n     * Get the plugin processors.\n     * The returned map cannot be mutated.\n     * @type {ReadonlyMap<string, Processor>} The plugin processors.\n     */\n    get pluginProcessors() {\n        return ensurePluginMemberMaps(this).processorMap;\n    }\n\n    /**\n     * Get the plugin rules.\n     * The returned map cannot be mutated.\n     * @returns {ReadonlyMap<string, Rule>} The plugin rules.\n     */\n    get pluginRules() {\n        return ensurePluginMemberMaps(this).ruleMap;\n    }\n\n    /**\n     * Check if this config has `root` flag.\n     * @returns {boolean} `true` if this config array is root.\n     */\n    isRoot() {\n        for (let i = this.length - 1; i >= 0; --i) {\n            const root = this[i].root;\n\n            if (typeof root === \"boolean\") {\n                return root;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Extract the config data which is related to a given file.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {ExtractedConfig} The extracted config data.\n     */\n    extractConfig(filePath) {\n        const { cache } = internalSlotsMap.get(this);\n        const indices = getMatchedIndices(this, filePath);\n        const cacheKey = indices.join(\",\");\n\n        if (!cache.has(cacheKey)) {\n            cache.set(cacheKey, createConfig(this, indices));\n        }\n\n        return cache.get(cacheKey);\n    }\n\n    /**\n     * Check if a given path is an additional lint target.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {boolean} `true` if the file is an additional lint target.\n     */\n    isAdditionalTargetPath(filePath) {\n        for (const { criteria, type } of this) {\n            if (\n                type === \"config\" &&\n                criteria &&\n                !criteria.endsWithWildcard &&\n                criteria.test(filePath)\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Get the used extracted configs.\n * CLIEngine will use this method to collect used deprecated rules.\n * @param {ConfigArray} instance The config array object to get.\n * @returns {ExtractedConfig[]} The used extracted configs.\n * @private\n */\nfunction getUsedExtractedConfigs(instance) {\n    const { cache } = internalSlotsMap.get(instance);\n\n    return Array.from(cache.values());\n}\n\n\nexport {\n    ConfigArray,\n    getUsedExtractedConfigs\n};\n","/**\n * @fileoverview `ConfigDependency` class.\n *\n * `ConfigDependency` class expresses a loaded parser or plugin.\n *\n * If the parser or plugin was loaded successfully, it has `definition` property\n * and `filePath` property. Otherwise, it has `error` property.\n *\n * When `JSON.stringify()` converted a `ConfigDependency` object to a JSON, it\n * omits `definition` property.\n *\n * `ConfigArrayFactory` creates `ConfigDependency` objects when it loads parsers\n * or plugins.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\nimport util from \"util\";\n\n/**\n * The class is to store parsers or plugins.\n * This class hides the loaded object from `JSON.stringify()` and `console.log`.\n * @template T\n */\nclass ConfigDependency {\n\n    /**\n     * Initialize this instance.\n     * @param {Object} data The dependency data.\n     * @param {T} [data.definition] The dependency if the loading succeeded.\n     * @param {Error} [data.error] The error object if the loading failed.\n     * @param {string} [data.filePath] The actual path to the dependency if the loading succeeded.\n     * @param {string} data.id The ID of this dependency.\n     * @param {string} data.importerName The name of the config file which loads this dependency.\n     * @param {string} data.importerPath The path to the config file which loads this dependency.\n     */\n    constructor({\n        definition = null,\n        error = null,\n        filePath = null,\n        id,\n        importerName,\n        importerPath\n    }) {\n\n        /**\n         * The loaded dependency if the loading succeeded.\n         * @type {T|null}\n         */\n        this.definition = definition;\n\n        /**\n         * The error object if the loading failed.\n         * @type {Error|null}\n         */\n        this.error = error;\n\n        /**\n         * The loaded dependency if the loading succeeded.\n         * @type {string|null}\n         */\n        this.filePath = filePath;\n\n        /**\n         * The ID of this dependency.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * The name of the config file which loads this dependency.\n         * @type {string}\n         */\n        this.importerName = importerName;\n\n        /**\n         * The path to the config file which loads this dependency.\n         * @type {string}\n         */\n        this.importerPath = importerPath;\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} a JSON compatible object.\n     */\n    toJSON() {\n        const obj = this[util.inspect.custom]();\n\n        // Display `error.message` (`Error#message` is unenumerable).\n        if (obj.error instanceof Error) {\n            obj.error = { ...obj.error, message: obj.error.message };\n        }\n\n        return obj;\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} an object to display by `console.log()`.\n     */\n    [util.inspect.custom]() {\n        const {\n            definition: _ignore, // eslint-disable-line no-unused-vars\n            ...obj\n        } = this;\n\n        return obj;\n    }\n}\n\n/** @typedef {ConfigDependency<import(\"../../shared/types\").Parser>} DependentParser */\n/** @typedef {ConfigDependency<import(\"../../shared/types\").Plugin>} DependentPlugin */\n\nexport { ConfigDependency };\n","/**\n * @fileoverview `OverrideTester` class.\n *\n * `OverrideTester` class handles `files` property and `excludedFiles` property\n * of `overrides` config.\n *\n * It provides one method.\n *\n * - `test(filePath)`\n *      Test if a file path matches the pair of `files` property and\n *      `excludedFiles` property. The `filePath` argument must be an absolute\n *      path.\n *\n * `ConfigArrayFactory` creates `OverrideTester` objects when it processes\n * `overrides` properties.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\nimport assert from \"assert\";\nimport path from \"path\";\nimport util from \"util\";\nimport minimatch from \"minimatch\";\n\nconst { Minimatch } = minimatch;\n\nconst minimatchOpts = { dot: true, matchBase: true };\n\n/**\n * @typedef {Object} Pattern\n * @property {InstanceType<Minimatch>[] | null} includes The positive matchers.\n * @property {InstanceType<Minimatch>[] | null} excludes The negative matchers.\n */\n\n/**\n * Normalize a given pattern to an array.\n * @param {string|string[]|undefined} patterns A glob pattern or an array of glob patterns.\n * @returns {string[]|null} Normalized patterns.\n * @private\n */\nfunction normalizePatterns(patterns) {\n    if (Array.isArray(patterns)) {\n        return patterns.filter(Boolean);\n    }\n    if (typeof patterns === \"string\" && patterns) {\n        return [patterns];\n    }\n    return [];\n}\n\n/**\n * Create the matchers of given patterns.\n * @param {string[]} patterns The patterns.\n * @returns {InstanceType<Minimatch>[] | null} The matchers.\n */\nfunction toMatcher(patterns) {\n    if (patterns.length === 0) {\n        return null;\n    }\n    return patterns.map(pattern => {\n        if (/^\\.[/\\\\]/u.test(pattern)) {\n            return new Minimatch(\n                pattern.slice(2),\n\n                // `./*.js` should not match with `subdir/foo.js`\n                { ...minimatchOpts, matchBase: false }\n            );\n        }\n        return new Minimatch(pattern, minimatchOpts);\n    });\n}\n\n/**\n * Convert a given matcher to string.\n * @param {Pattern} matchers The matchers.\n * @returns {string} The string expression of the matcher.\n */\nfunction patternToJson({ includes, excludes }) {\n    return {\n        includes: includes && includes.map(m => m.pattern),\n        excludes: excludes && excludes.map(m => m.pattern)\n    };\n}\n\n/**\n * The class to test given paths are matched by the patterns.\n */\nclass OverrideTester {\n\n    /**\n     * Create a tester with given criteria.\n     * If there are no criteria, returns `null`.\n     * @param {string|string[]} files The glob patterns for included files.\n     * @param {string|string[]} excludedFiles The glob patterns for excluded files.\n     * @param {string} basePath The path to the base directory to test paths.\n     * @returns {OverrideTester|null} The created instance or `null`.\n     */\n    static create(files, excludedFiles, basePath) {\n        const includePatterns = normalizePatterns(files);\n        const excludePatterns = normalizePatterns(excludedFiles);\n        let endsWithWildcard = false;\n\n        if (includePatterns.length === 0) {\n            return null;\n        }\n\n        // Rejects absolute paths or relative paths to parents.\n        for (const pattern of includePatterns) {\n            if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n            }\n            if (pattern.endsWith(\"*\")) {\n                endsWithWildcard = true;\n            }\n        }\n        for (const pattern of excludePatterns) {\n            if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n            }\n        }\n\n        const includes = toMatcher(includePatterns);\n        const excludes = toMatcher(excludePatterns);\n\n        return new OverrideTester(\n            [{ includes, excludes }],\n            basePath,\n            endsWithWildcard\n        );\n    }\n\n    /**\n     * Combine two testers by logical and.\n     * If either of the testers was `null`, returns the other tester.\n     * The `basePath` property of the two must be the same value.\n     * @param {OverrideTester|null} a A tester.\n     * @param {OverrideTester|null} b Another tester.\n     * @returns {OverrideTester|null} Combined tester.\n     */\n    static and(a, b) {\n        if (!b) {\n            return a && new OverrideTester(\n                a.patterns,\n                a.basePath,\n                a.endsWithWildcard\n            );\n        }\n        if (!a) {\n            return new OverrideTester(\n                b.patterns,\n                b.basePath,\n                b.endsWithWildcard\n            );\n        }\n\n        assert.strictEqual(a.basePath, b.basePath);\n        return new OverrideTester(\n            a.patterns.concat(b.patterns),\n            a.basePath,\n            a.endsWithWildcard || b.endsWithWildcard\n        );\n    }\n\n    /**\n     * Initialize this instance.\n     * @param {Pattern[]} patterns The matchers.\n     * @param {string} basePath The base path.\n     * @param {boolean} endsWithWildcard If `true` then a pattern ends with `*`.\n     */\n    constructor(patterns, basePath, endsWithWildcard = false) {\n\n        /** @type {Pattern[]} */\n        this.patterns = patterns;\n\n        /** @type {string} */\n        this.basePath = basePath;\n\n        /** @type {boolean} */\n        this.endsWithWildcard = endsWithWildcard;\n    }\n\n    /**\n     * Test if a given path is matched or not.\n     * @param {string} filePath The absolute path to the target file.\n     * @returns {boolean} `true` if the path was matched.\n     */\n    test(filePath) {\n        if (typeof filePath !== \"string\" || !path.isAbsolute(filePath)) {\n            throw new Error(`'filePath' should be an absolute path, but got ${filePath}.`);\n        }\n        const relativePath = path.relative(this.basePath, filePath);\n\n        return this.patterns.every(({ includes, excludes }) => (\n            (!includes || includes.some(m => m.match(relativePath))) &&\n            (!excludes || !excludes.some(m => m.match(relativePath)))\n        ));\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} a JSON compatible object.\n     */\n    toJSON() {\n        if (this.patterns.length === 1) {\n            return {\n                ...patternToJson(this.patterns[0]),\n                basePath: this.basePath\n            };\n        }\n        return {\n            AND: this.patterns.map(patternToJson),\n            basePath: this.basePath\n        };\n    }\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @returns {Object} an object to display by `console.log()`.\n     */\n    [util.inspect.custom]() {\n        return this.toJSON();\n    }\n}\n\nexport { OverrideTester };\n","/**\n * @fileoverview `ConfigArray` class.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\nimport { ConfigArray, getUsedExtractedConfigs } from \"./config-array.js\";\nimport { ConfigDependency } from \"./config-dependency.js\";\nimport { ExtractedConfig } from \"./extracted-config.js\";\nimport { IgnorePattern } from \"./ignore-pattern.js\";\nimport { OverrideTester } from \"./override-tester.js\";\n\nexport {\n    ConfigArray,\n    ConfigDependency,\n    ExtractedConfig,\n    IgnorePattern,\n    OverrideTester,\n    getUsedExtractedConfigs\n};\n","/**\n * @fileoverview Config file operations. This file must be usable in the browser,\n * so no Node-specific code can be here.\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst RULE_SEVERITY_STRINGS = [\"off\", \"warn\", \"error\"],\n    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {\n        map[value] = index;\n        return map;\n    }, {}),\n    VALID_SEVERITIES = [0, 1, 2, \"off\", \"warn\", \"error\"];\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Normalizes the severity value of a rule's configuration to a number\n * @param {(number|string|[number, ...*]|[string, ...*])} ruleConfig A rule's configuration value, generally\n * received from the user. A valid config value is either 0, 1, 2, the string \"off\" (treated the same as 0),\n * the string \"warn\" (treated the same as 1), the string \"error\" (treated the same as 2), or an array\n * whose first element is one of the above values. Strings are matched case-insensitively.\n * @returns {(0|1|2)} The numeric severity value if the config value was valid, otherwise 0.\n */\nfunction getRuleSeverity(ruleConfig) {\n    const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n    if (severityValue === 0 || severityValue === 1 || severityValue === 2) {\n        return severityValue;\n    }\n\n    if (typeof severityValue === \"string\") {\n        return RULE_SEVERITY[severityValue.toLowerCase()] || 0;\n    }\n\n    return 0;\n}\n\n/**\n * Converts old-style severity settings (0, 1, 2) into new-style\n * severity settings (off, warn, error) for all rules. Assumption is that severity\n * values have already been validated as correct.\n * @param {Object} config The config object to normalize.\n * @returns {void}\n */\nfunction normalizeToStrings(config) {\n\n    if (config.rules) {\n        Object.keys(config.rules).forEach(ruleId => {\n            const ruleConfig = config.rules[ruleId];\n\n            if (typeof ruleConfig === \"number\") {\n                config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];\n            } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === \"number\") {\n                ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];\n            }\n        });\n    }\n}\n\n/**\n * Determines if the severity for the given rule configuration represents an error.\n * @param {int|string|Array} ruleConfig The configuration for an individual rule.\n * @returns {boolean} True if the rule represents an error, false if not.\n */\nfunction isErrorSeverity(ruleConfig) {\n    return getRuleSeverity(ruleConfig) === 2;\n}\n\n/**\n * Checks whether a given config has valid severity or not.\n * @param {number|string|Array} ruleConfig The configuration for an individual rule.\n * @returns {boolean} `true` if the configuration has valid severity.\n */\nfunction isValidSeverity(ruleConfig) {\n    let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n    if (typeof severity === \"string\") {\n        severity = severity.toLowerCase();\n    }\n    return VALID_SEVERITIES.indexOf(severity) !== -1;\n}\n\n/**\n * Checks whether every rule of a given config has valid severity or not.\n * @param {Object} config The configuration for rules.\n * @returns {boolean} `true` if the configuration has valid severity.\n */\nfunction isEverySeverityValid(config) {\n    return Object.keys(config).every(ruleId => isValidSeverity(config[ruleId]));\n}\n\n/**\n * Normalizes a value for a global in a config\n * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in\n * a global directive comment\n * @returns {(\"readable\"|\"writeable\"|\"off\")} The value normalized as a string\n * @throws Error if global value is invalid\n */\nfunction normalizeConfigGlobal(configuredValue) {\n    switch (configuredValue) {\n        case \"off\":\n            return \"off\";\n\n        case true:\n        case \"true\":\n        case \"writeable\":\n        case \"writable\":\n            return \"writable\";\n\n        case null:\n        case false:\n        case \"false\":\n        case \"readable\":\n        case \"readonly\":\n            return \"readonly\";\n\n        default:\n            throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);\n    }\n}\n\nexport {\n    getRuleSeverity,\n    normalizeToStrings,\n    isErrorSeverity,\n    isValidSeverity,\n    isEverySeverityValid,\n    normalizeConfigGlobal\n};\n","/**\n * @fileoverview Provide the function that emits deprecation warnings.\n * @author Toru Nagashima <http://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport path from \"path\";\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n// Defitions for deprecation warnings.\nconst deprecationWarningMessages = {\n    ESLINT_LEGACY_ECMAFEATURES:\n        \"The 'ecmaFeatures' config file property is deprecated and has no effect.\",\n    ESLINT_PERSONAL_CONFIG_LOAD:\n        \"'~/.eslintrc.*' config files have been deprecated. \" +\n        \"Please use a config file per project or the '--config' option.\",\n    ESLINT_PERSONAL_CONFIG_SUPPRESS:\n        \"'~/.eslintrc.*' config files have been deprecated. \" +\n        \"Please remove it or add 'root:true' to the config files in your \" +\n        \"projects in order to avoid loading '~/.eslintrc.*' accidentally.\"\n};\n\nconst sourceFileErrorCache = new Set();\n\n/**\n * Emits a deprecation warning containing a given filepath. A new deprecation warning is emitted\n * for each unique file path, but repeated invocations with the same file path have no effect.\n * No warnings are emitted if the `--no-deprecation` or `--no-warnings` Node runtime flags are active.\n * @param {string} source The name of the configuration source to report the warning for.\n * @param {string} errorCode The warning message to show.\n * @returns {void}\n */\nfunction emitDeprecationWarning(source, errorCode) {\n    const cacheKey = JSON.stringify({ source, errorCode });\n\n    if (sourceFileErrorCache.has(cacheKey)) {\n        return;\n    }\n    sourceFileErrorCache.add(cacheKey);\n\n    const rel = path.relative(process.cwd(), source);\n    const message = deprecationWarningMessages[errorCode];\n\n    process.emitWarning(\n        `${message} (found in \"${rel}\")`,\n        \"DeprecationWarning\",\n        errorCode\n    );\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nexport {\n    emitDeprecationWarning\n};\n","/**\n * @fileoverview The instance of Ajv validator.\n * @author Evgeny Poberezkin\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport Ajv from \"ajv\";\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/*\n * Copied from ajv/lib/refs/json-schema-draft-04.json\n * The MIT License (MIT)\n * Copyright (c) 2015-2017 Evgeny Poberezkin\n */\nconst metaSchema = {\n    id: \"http://json-schema.org/draft-04/schema#\",\n    $schema: \"http://json-schema.org/draft-04/schema#\",\n    description: \"Core schema meta-schema\",\n    definitions: {\n        schemaArray: {\n            type: \"array\",\n            minItems: 1,\n            items: { $ref: \"#\" }\n        },\n        positiveInteger: {\n            type: \"integer\",\n            minimum: 0\n        },\n        positiveIntegerDefault0: {\n            allOf: [{ $ref: \"#/definitions/positiveInteger\" }, { default: 0 }]\n        },\n        simpleTypes: {\n            enum: [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n        },\n        stringArray: {\n            type: \"array\",\n            items: { type: \"string\" },\n            minItems: 1,\n            uniqueItems: true\n        }\n    },\n    type: \"object\",\n    properties: {\n        id: {\n            type: \"string\"\n        },\n        $schema: {\n            type: \"string\"\n        },\n        title: {\n            type: \"string\"\n        },\n        description: {\n            type: \"string\"\n        },\n        default: { },\n        multipleOf: {\n            type: \"number\",\n            minimum: 0,\n            exclusiveMinimum: true\n        },\n        maximum: {\n            type: \"number\"\n        },\n        exclusiveMaximum: {\n            type: \"boolean\",\n            default: false\n        },\n        minimum: {\n            type: \"number\"\n        },\n        exclusiveMinimum: {\n            type: \"boolean\",\n            default: false\n        },\n        maxLength: { $ref: \"#/definitions/positiveInteger\" },\n        minLength: { $ref: \"#/definitions/positiveIntegerDefault0\" },\n        pattern: {\n            type: \"string\",\n            format: \"regex\"\n        },\n        additionalItems: {\n            anyOf: [\n                { type: \"boolean\" },\n                { $ref: \"#\" }\n            ],\n            default: { }\n        },\n        items: {\n            anyOf: [\n                { $ref: \"#\" },\n                { $ref: \"#/definitions/schemaArray\" }\n            ],\n            default: { }\n        },\n        maxItems: { $ref: \"#/definitions/positiveInteger\" },\n        minItems: { $ref: \"#/definitions/positiveIntegerDefault0\" },\n        uniqueItems: {\n            type: \"boolean\",\n            default: false\n        },\n        maxProperties: { $ref: \"#/definitions/positiveInteger\" },\n        minProperties: { $ref: \"#/definitions/positiveIntegerDefault0\" },\n        required: { $ref: \"#/definitions/stringArray\" },\n        additionalProperties: {\n            anyOf: [\n                { type: \"boolean\" },\n                { $ref: \"#\" }\n            ],\n            default: { }\n        },\n        definitions: {\n            type: \"object\",\n            additionalProperties: { $ref: \"#\" },\n            default: { }\n        },\n        properties: {\n            type: \"object\",\n            additionalProperties: { $ref: \"#\" },\n            default: { }\n        },\n        patternProperties: {\n            type: \"object\",\n            additionalProperties: { $ref: \"#\" },\n            default: { }\n        },\n        dependencies: {\n            type: \"object\",\n            additionalProperties: {\n                anyOf: [\n                    { $ref: \"#\" },\n                    { $ref: \"#/definitions/stringArray\" }\n                ]\n            }\n        },\n        enum: {\n            type: \"array\",\n            minItems: 1,\n            uniqueItems: true\n        },\n        type: {\n            anyOf: [\n                { $ref: \"#/definitions/simpleTypes\" },\n                {\n                    type: \"array\",\n                    items: { $ref: \"#/definitions/simpleTypes\" },\n                    minItems: 1,\n                    uniqueItems: true\n                }\n            ]\n        },\n        format: { type: \"string\" },\n        allOf: { $ref: \"#/definitions/schemaArray\" },\n        anyOf: { $ref: \"#/definitions/schemaArray\" },\n        oneOf: { $ref: \"#/definitions/schemaArray\" },\n        not: { $ref: \"#\" }\n    },\n    dependencies: {\n        exclusiveMaximum: [\"maximum\"],\n        exclusiveMinimum: [\"minimum\"]\n    },\n    default: { }\n};\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nexport default (additionalOptions = {}) => {\n    const ajv = new Ajv({\n        meta: false,\n        useDefaults: true,\n        validateSchema: false,\n        missingRefs: \"ignore\",\n        verbose: true,\n        schemaId: \"auto\",\n        ...additionalOptions\n    });\n\n    ajv.addMetaSchema(metaSchema);\n    // eslint-disable-next-line no-underscore-dangle\n    ajv._opts.defaultMeta = metaSchema.id;\n\n    return ajv;\n};\n","/**\n * @fileoverview Defines a schema for configs.\n * @author Sylvan Mably\n */\n\nconst baseConfigProperties = {\n    $schema: { type: \"string\" },\n    env: { type: \"object\" },\n    extends: { $ref: \"#/definitions/stringOrStrings\" },\n    globals: { type: \"object\" },\n    overrides: {\n        type: \"array\",\n        items: { $ref: \"#/definitions/overrideConfig\" },\n        additionalItems: false\n    },\n    parser: { type: [\"string\", \"null\"] },\n    parserOptions: { type: \"object\" },\n    plugins: { type: \"array\" },\n    processor: { type: \"string\" },\n    rules: { type: \"object\" },\n    settings: { type: \"object\" },\n    noInlineConfig: { type: \"boolean\" },\n    reportUnusedDisableDirectives: { type: \"boolean\" },\n\n    ecmaFeatures: { type: \"object\" } // deprecated; logs a warning when used\n};\n\nconst configSchema = {\n    definitions: {\n        stringOrStrings: {\n            oneOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                    additionalItems: false\n                }\n            ]\n        },\n        stringOrStringsRequired: {\n            oneOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                    additionalItems: false,\n                    minItems: 1\n                }\n            ]\n        },\n\n        // Config at top-level.\n        objectConfig: {\n            type: \"object\",\n            properties: {\n                root: { type: \"boolean\" },\n                ignorePatterns: { $ref: \"#/definitions/stringOrStrings\" },\n                ...baseConfigProperties\n            },\n            additionalProperties: false\n        },\n\n        // Config in `overrides`.\n        overrideConfig: {\n            type: \"object\",\n            properties: {\n                excludedFiles: { $ref: \"#/definitions/stringOrStrings\" },\n                files: { $ref: \"#/definitions/stringOrStringsRequired\" },\n                ...baseConfigProperties\n            },\n            required: [\"files\"],\n            additionalProperties: false\n        }\n    },\n\n    $ref: \"#/definitions/objectConfig\"\n};\n\nexport default configSchema;\n","/**\n * @fileoverview Defines environment settings and globals.\n * @author Elan Shanker\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport globals from \"globals\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the object that has difference.\n * @param {Record<string,boolean>} current The newer object.\n * @param {Record<string,boolean>} prev The older object.\n * @returns {Record<string,boolean>} The difference object.\n */\nfunction getDiff(current, prev) {\n    const retv = {};\n\n    for (const [key, value] of Object.entries(current)) {\n        if (!Object.hasOwnProperty.call(prev, key)) {\n            retv[key] = value;\n        }\n    }\n\n    return retv;\n}\n\nconst newGlobals2015 = getDiff(globals.es2015, globals.es5); // 19 variables such as Promise, Map, ...\nconst newGlobals2017 = {\n    Atomics: false,\n    SharedArrayBuffer: false\n};\nconst newGlobals2020 = {\n    BigInt: false,\n    BigInt64Array: false,\n    BigUint64Array: false,\n    globalThis: false\n};\n\nconst newGlobals2021 = {\n    AggregateError: false,\n    FinalizationRegistry: false,\n    WeakRef: false\n};\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/** @type {Map<string, import(\"../lib/shared/types\").Environment>} */\nexport default new Map(Object.entries({\n\n    // Language\n    builtin: {\n        globals: globals.es5\n    },\n    es6: {\n        globals: newGlobals2015,\n        parserOptions: {\n            ecmaVersion: 6\n        }\n    },\n    es2015: {\n        globals: newGlobals2015,\n        parserOptions: {\n            ecmaVersion: 6\n        }\n    },\n    es2016: {\n        globals: newGlobals2015,\n        parserOptions: {\n            ecmaVersion: 7\n        }\n    },\n    es2017: {\n        globals: { ...newGlobals2015, ...newGlobals2017 },\n        parserOptions: {\n            ecmaVersion: 8\n        }\n    },\n    es2018: {\n        globals: { ...newGlobals2015, ...newGlobals2017 },\n        parserOptions: {\n            ecmaVersion: 9\n        }\n    },\n    es2019: {\n        globals: { ...newGlobals2015, ...newGlobals2017 },\n        parserOptions: {\n            ecmaVersion: 10\n        }\n    },\n    es2020: {\n        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020 },\n        parserOptions: {\n            ecmaVersion: 11\n        }\n    },\n    es2021: {\n        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },\n        parserOptions: {\n            ecmaVersion: 12\n        }\n    },\n    es2022: {\n        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },\n        parserOptions: {\n            ecmaVersion: 13\n        }\n    },\n\n    // Platforms\n    browser: {\n        globals: globals.browser\n    },\n    node: {\n        globals: globals.node,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    \"shared-node-browser\": {\n        globals: globals[\"shared-node-browser\"]\n    },\n    worker: {\n        globals: globals.worker\n    },\n    serviceworker: {\n        globals: globals.serviceworker\n    },\n\n    // Frameworks\n    commonjs: {\n        globals: globals.commonjs,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    amd: {\n        globals: globals.amd\n    },\n    mocha: {\n        globals: globals.mocha\n    },\n    jasmine: {\n        globals: globals.jasmine\n    },\n    jest: {\n        globals: globals.jest\n    },\n    phantomjs: {\n        globals: globals.phantomjs\n    },\n    jquery: {\n        globals: globals.jquery\n    },\n    qunit: {\n        globals: globals.qunit\n    },\n    prototypejs: {\n        globals: globals.prototypejs\n    },\n    shelljs: {\n        globals: globals.shelljs\n    },\n    meteor: {\n        globals: globals.meteor\n    },\n    mongo: {\n        globals: globals.mongo\n    },\n    protractor: {\n        globals: globals.protractor\n    },\n    applescript: {\n        globals: globals.applescript\n    },\n    nashorn: {\n        globals: globals.nashorn\n    },\n    atomtest: {\n        globals: globals.atomtest\n    },\n    embertest: {\n        globals: globals.embertest\n    },\n    webextensions: {\n        globals: globals.webextensions\n    },\n    greasemonkey: {\n        globals: globals.greasemonkey\n    }\n}));\n","/**\n * @fileoverview Validates configs.\n * @author Brandon Mills\n */\n\n/* eslint class-methods-use-this: \"off\" */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport util from \"util\";\nimport * as ConfigOps from \"./config-ops.js\";\nimport { emitDeprecationWarning } from \"./deprecation-warnings.js\";\nimport ajvOrig from \"./ajv.js\";\nimport configSchema from \"../../conf/config-schema.js\";\nimport BuiltInEnvironments from \"../../conf/environments.js\";\n\nconst ajv = ajvOrig();\n\nconst ruleValidators = new WeakMap();\nconst noop = Function.prototype;\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\nlet validateSchema;\nconst severityMap = {\n    error: 2,\n    warn: 1,\n    off: 0\n};\n\nconst validated = new WeakSet();\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nexport default class ConfigValidator {\n    constructor({ builtInRules = new Map() } = {}) {\n        this.builtInRules = builtInRules;\n    }\n\n    /**\n     * Gets a complete options schema for a rule.\n     * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n     * @returns {Object} JSON Schema for the rule's options.\n     */\n    getRuleOptionsSchema(rule) {\n        if (!rule) {\n            return null;\n        }\n\n        const schema = rule.schema || rule.meta && rule.meta.schema;\n\n        // Given a tuple of schemas, insert warning level at the beginning\n        if (Array.isArray(schema)) {\n            if (schema.length) {\n                return {\n                    type: \"array\",\n                    items: schema,\n                    minItems: 0,\n                    maxItems: schema.length\n                };\n            }\n            return {\n                type: \"array\",\n                minItems: 0,\n                maxItems: 0\n            };\n\n        }\n\n        // Given a full schema, leave it alone\n        return schema || null;\n    }\n\n    /**\n     * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\n     * @param {options} options The given options for the rule.\n     * @returns {number|string} The rule's severity value\n     */\n    validateRuleSeverity(options) {\n        const severity = Array.isArray(options) ? options[0] : options;\n        const normSeverity = typeof severity === \"string\" ? severityMap[severity.toLowerCase()] : severity;\n\n        if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {\n            return normSeverity;\n        }\n\n        throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, \"\\\"\").replace(/\\n/gu, \"\")}').\\n`);\n\n    }\n\n    /**\n     * Validates the non-severity options passed to a rule, based on its schema.\n     * @param {{create: Function}} rule The rule to validate\n     * @param {Array} localOptions The options for the rule, excluding severity\n     * @returns {void}\n     */\n    validateRuleSchema(rule, localOptions) {\n        if (!ruleValidators.has(rule)) {\n            const schema = this.getRuleOptionsSchema(rule);\n\n            if (schema) {\n                ruleValidators.set(rule, ajv.compile(schema));\n            }\n        }\n\n        const validateRule = ruleValidators.get(rule);\n\n        if (validateRule) {\n            validateRule(localOptions);\n            if (validateRule.errors) {\n                throw new Error(validateRule.errors.map(\n                    error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`\n                ).join(\"\"));\n            }\n        }\n    }\n\n    /**\n     * Validates a rule's options against its schema.\n     * @param {{create: Function}|null} rule The rule that the config is being validated for\n     * @param {string} ruleId The rule's unique name.\n     * @param {Array|number} options The given options for the rule.\n     * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,\n     * no source is prepended to the message.\n     * @returns {void}\n     */\n    validateRuleOptions(rule, ruleId, options, source = null) {\n        try {\n            const severity = this.validateRuleSeverity(options);\n\n            if (severity !== 0) {\n                this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);\n            }\n        } catch (err) {\n            const enhancedMessage = `Configuration for rule \"${ruleId}\" is invalid:\\n${err.message}`;\n\n            if (typeof source === \"string\") {\n                throw new Error(`${source}:\\n\\t${enhancedMessage}`);\n            } else {\n                throw new Error(enhancedMessage);\n            }\n        }\n    }\n\n    /**\n     * Validates an environment object\n     * @param {Object} environment The environment config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.\n     * @returns {void}\n     */\n    validateEnvironment(\n        environment,\n        source,\n        getAdditionalEnv = noop\n    ) {\n\n        // not having an environment is ok\n        if (!environment) {\n            return;\n        }\n\n        Object.keys(environment).forEach(id => {\n            const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;\n\n            if (!env) {\n                const message = `${source}:\\n\\tEnvironment key \"${id}\" is unknown\\n`;\n\n                throw new Error(message);\n            }\n        });\n    }\n\n    /**\n     * Validates a rules config object\n     * @param {Object} rulesConfig The rules config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules\n     * @returns {void}\n     */\n    validateRules(\n        rulesConfig,\n        source,\n        getAdditionalRule = noop\n    ) {\n        if (!rulesConfig) {\n            return;\n        }\n\n        Object.keys(rulesConfig).forEach(id => {\n            const rule = getAdditionalRule(id) || this.builtInRules.get(id) || null;\n\n            this.validateRuleOptions(rule, id, rulesConfig[id], source);\n        });\n    }\n\n    /**\n     * Validates a `globals` section of a config file\n     * @param {Object} globalsConfig The `globals` section\n     * @param {string|null} source The name of the configuration source to report in the event of an error.\n     * @returns {void}\n     */\n    validateGlobals(globalsConfig, source = null) {\n        if (!globalsConfig) {\n            return;\n        }\n\n        Object.entries(globalsConfig)\n            .forEach(([configuredGlobal, configuredValue]) => {\n                try {\n                    ConfigOps.normalizeConfigGlobal(configuredValue);\n                } catch (err) {\n                    throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:\\n${err.message}`);\n                }\n            });\n    }\n\n    /**\n     * Validate `processor` configuration.\n     * @param {string|undefined} processorName The processor name.\n     * @param {string} source The name of config file.\n     * @param {function(id:string): Processor} getProcessor The getter of defined processors.\n     * @returns {void}\n     */\n    validateProcessor(processorName, source, getProcessor) {\n        if (processorName && !getProcessor(processorName)) {\n            throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);\n        }\n    }\n\n    /**\n     * Formats an array of schema validation errors.\n     * @param {Array} errors An array of error messages to format.\n     * @returns {string} Formatted error message\n     */\n    formatErrors(errors) {\n        return errors.map(error => {\n            if (error.keyword === \"additionalProperties\") {\n                const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;\n\n                return `Unexpected top-level property \"${formattedPropertyPath}\"`;\n            }\n            if (error.keyword === \"type\") {\n                const formattedField = error.dataPath.slice(1);\n                const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join(\"/\") : error.schema;\n                const formattedValue = JSON.stringify(error.data);\n\n                return `Property \"${formattedField}\" is the wrong type (expected ${formattedExpectedType} but got \\`${formattedValue}\\`)`;\n            }\n\n            const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n\n            return `\"${field}\" ${error.message}. Value: ${JSON.stringify(error.data)}`;\n        }).map(message => `\\t- ${message}.\\n`).join(\"\");\n    }\n\n    /**\n     * Validates the top level properties of the config object.\n     * @param {Object} config The config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @returns {void}\n     */\n    validateConfigSchema(config, source = null) {\n        validateSchema = validateSchema || ajv.compile(configSchema);\n\n        if (!validateSchema(config)) {\n            throw new Error(`ESLint configuration in ${source} is invalid:\\n${this.formatErrors(validateSchema.errors)}`);\n        }\n\n        if (Object.hasOwnProperty.call(config, \"ecmaFeatures\")) {\n            emitDeprecationWarning(source, \"ESLINT_LEGACY_ECMAFEATURES\");\n        }\n    }\n\n    /**\n     * Validates an entire config object.\n     * @param {Object} config The config object to validate.\n     * @param {string} source The name of the configuration source to report in any errors.\n     * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.\n     * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.\n     * @returns {void}\n     */\n    validate(config, source, getAdditionalRule, getAdditionalEnv) {\n        this.validateConfigSchema(config, source);\n        this.validateRules(config.rules, source, getAdditionalRule);\n        this.validateEnvironment(config.env, source, getAdditionalEnv);\n        this.validateGlobals(config.globals, source);\n\n        for (const override of config.overrides || []) {\n            this.validateRules(override.rules, source, getAdditionalRule);\n            this.validateEnvironment(override.env, source, getAdditionalEnv);\n            this.validateGlobals(config.globals, source);\n        }\n    }\n\n    /**\n     * Validate config array object.\n     * @param {ConfigArray} configArray The config array to validate.\n     * @returns {void}\n     */\n    validateConfigArray(configArray) {\n        const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);\n        const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);\n        const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);\n\n        // Validate.\n        for (const element of configArray) {\n            if (validated.has(element)) {\n                continue;\n            }\n            validated.add(element);\n\n            this.validateEnvironment(element.env, element.name, getPluginEnv);\n            this.validateGlobals(element.globals, element.name);\n            this.validateProcessor(element.processor, element.name, getPluginProcessor);\n            this.validateRules(element.rules, element.name, getPluginRule);\n        }\n    }\n\n}\n","/**\n * @fileoverview Common helpers for naming of plugins, formatters and configs\n */\n\nconst NAMESPACE_REGEX = /^@.*\\//iu;\n\n/**\n * Brings package name to correct format based on prefix\n * @param {string} name The name of the package.\n * @param {string} prefix Can be either \"eslint-plugin\", \"eslint-config\" or \"eslint-formatter\"\n * @returns {string} Normalized name of the package\n * @private\n */\nfunction normalizePackageName(name, prefix) {\n    let normalizedName = name;\n\n    /**\n     * On Windows, name can come in with Windows slashes instead of Unix slashes.\n     * Normalize to Unix first to avoid errors later on.\n     * https://github.com/eslint/eslint/issues/5644\n     */\n    if (normalizedName.includes(\"\\\\\")) {\n        normalizedName = normalizedName.replace(/\\\\/gu, \"/\");\n    }\n\n    if (normalizedName.charAt(0) === \"@\") {\n\n        /**\n         * it's a scoped package\n         * package name is the prefix, or just a username\n         */\n        const scopedPackageShortcutRegex = new RegExp(`^(@[^/]+)(?:/(?:${prefix})?)?$`, \"u\"),\n            scopedPackageNameRegex = new RegExp(`^${prefix}(-|$)`, \"u\");\n\n        if (scopedPackageShortcutRegex.test(normalizedName)) {\n            normalizedName = normalizedName.replace(scopedPackageShortcutRegex, `$1/${prefix}`);\n        } else if (!scopedPackageNameRegex.test(normalizedName.split(\"/\")[1])) {\n\n            /**\n             * for scoped packages, insert the prefix after the first / unless\n             * the path is already @scope/eslint or @scope/eslint-xxx-yyy\n             */\n            normalizedName = normalizedName.replace(/^@([^/]+)\\/(.*)$/u, `@$1/${prefix}-$2`);\n        }\n    } else if (!normalizedName.startsWith(`${prefix}-`)) {\n        normalizedName = `${prefix}-${normalizedName}`;\n    }\n\n    return normalizedName;\n}\n\n/**\n * Removes the prefix from a fullname.\n * @param {string} fullname The term which may have the prefix.\n * @param {string} prefix The prefix to remove.\n * @returns {string} The term without prefix.\n */\nfunction getShorthandName(fullname, prefix) {\n    if (fullname[0] === \"@\") {\n        let matchResult = new RegExp(`^(@[^/]+)/${prefix}$`, \"u\").exec(fullname);\n\n        if (matchResult) {\n            return matchResult[1];\n        }\n\n        matchResult = new RegExp(`^(@[^/]+)/${prefix}-(.+)$`, \"u\").exec(fullname);\n        if (matchResult) {\n            return `${matchResult[1]}/${matchResult[2]}`;\n        }\n    } else if (fullname.startsWith(`${prefix}-`)) {\n        return fullname.slice(prefix.length + 1);\n    }\n\n    return fullname;\n}\n\n/**\n * Gets the scope (namespace) of a term.\n * @param {string} term The term which may have the namespace.\n * @returns {string} The namespace of the term if it has one.\n */\nfunction getNamespaceFromTerm(term) {\n    const match = term.match(NAMESPACE_REGEX);\n\n    return match ? match[0] : \"\";\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nexport {\n    normalizePackageName,\n    getShorthandName,\n    getNamespaceFromTerm\n};\n","/**\n * Utility for resolving a module relative to another module\n * @author Teddy Katz\n */\n\nimport Module from \"module\";\n\n/*\n * `Module.createRequire` is added in v12.2.0. It supports URL as well.\n * We only support the case where the argument is a filepath, not a URL.\n */\nconst createRequire = Module.createRequire;\n\n/**\n * Resolves a Node module relative to another module\n * @param {string} moduleName The name of a Node module, or a path to a Node module.\n * @param {string} relativeToPath An absolute path indicating the module that `moduleName` should be resolved relative to. This must be\n * a file rather than a directory, but the file need not actually exist.\n * @returns {string} The absolute path that would result from calling `require.resolve(moduleName)` in a file located at `relativeToPath`\n */\nfunction resolve(moduleName, relativeToPath) {\n    try {\n        return createRequire(relativeToPath).resolve(moduleName);\n    } catch (error) {\n\n        // This `if` block is for older Node.js than 12.0.0. We can remove this block in the future.\n        if (\n            typeof error === \"object\" &&\n            error !== null &&\n            error.code === \"MODULE_NOT_FOUND\" &&\n            !error.requireStack &&\n            error.message.includes(moduleName)\n        ) {\n            error.message += `\\nRequire stack:\\n- ${relativeToPath}`;\n        }\n        throw error;\n    }\n}\n\nexport {\n    resolve\n};\n","/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport debugOrig from \"debug\";\nimport fs from \"fs\";\nimport importFresh from \"import-fresh\";\nimport { createRequire } from \"module\";\nimport path from \"path\";\nimport stripComments from \"strip-json-comments\";\n\nimport {\n    ConfigArray,\n    ConfigDependency,\n    IgnorePattern,\n    OverrideTester\n} from \"./config-array/index.js\";\nimport ConfigValidator from \"./shared/config-validator.js\";\nimport * as naming from \"./shared/naming.js\";\nimport * as ModuleResolver from \"./shared/relative-module-resolver.js\";\n\nconst require = createRequire(import.meta.url);\n\nconst debug = debugOrig(\"eslintrc:config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst configFilenames = [\n    \".eslintrc.js\",\n    \".eslintrc.cjs\",\n    \".eslintrc.yaml\",\n    \".eslintrc.yml\",\n    \".eslintrc.json\",\n    \".eslintrc\",\n    \"package.json\"\n];\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"./shared/types\").OverrideConfigData} OverrideConfigData */\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {string} pluginBasePath The base path to resolve plugins.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/** @type {WeakMap<object, Plugin>} */\nconst normalizedPlugins = new WeakMap();\n\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\nfunction isFilePath(nameOrPath) {\n    return (\n        /^\\.{1,2}[/\\\\]/u.test(nameOrPath) ||\n        path.isAbsolute(nameOrPath)\n    );\n}\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\nfunction readFile(filePath) {\n    return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n    debug(`Loading YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n\n        // empty YAML file can be null, so always use\n        return yaml.load(readFile(filePath)) || {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n    debug(`Loading JSON config file: ${filePath}`);\n\n    try {\n        return JSON.parse(stripComments(readFile(filePath)));\n    } catch (e) {\n        debug(`Error reading JSON file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        e.messageTemplate = \"failed-to-read-json\";\n        e.messageData = {\n            path: filePath,\n            message: e.message\n        };\n        throw e;\n    }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n    debug(`Loading legacy config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n        return yaml.load(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};\n    } catch (e) {\n        debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n    debug(`Loading JS config file: ${filePath}`);\n    try {\n        return importFresh(filePath);\n    } catch (e) {\n        debug(`Error reading JavaScript file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n    debug(`Loading package.json config file: ${filePath}`);\n    try {\n        const packageData = loadJSONConfigFile(filePath);\n\n        if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n            throw Object.assign(\n                new Error(\"package.json file doesn't have 'eslintConfig' field.\"),\n                { code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\" }\n            );\n        }\n\n        return packageData.eslintConfig;\n    } catch (e) {\n        debug(`Error reading package.json file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\nfunction loadESLintIgnoreFile(filePath) {\n    debug(`Loading .eslintignore file: ${filePath}`);\n\n    try {\n        return readFile(filePath)\n            .split(/\\r?\\n/gu)\n            .filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n    } catch (e) {\n        debug(`Error reading .eslintignore file: ${filePath}`);\n        e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @param {string} messageTemplate The text template to source error strings from.\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configInvalidError(configName, importerName, messageTemplate) {\n    return Object.assign(\n        new Error(`Failed to load config \"${configName}\" to extend from.`),\n        {\n            messageTemplate,\n            messageData: { configName, importerName }\n        }\n    );\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\nfunction loadConfigFile(filePath) {\n    switch (path.extname(filePath)) {\n        case \".js\":\n        case \".cjs\":\n            return loadJSConfigFile(filePath);\n\n        case \".json\":\n            if (path.basename(filePath) === \"package.json\") {\n                return loadPackageJSONConfigFile(filePath);\n            }\n            return loadJSONConfigFile(filePath);\n\n        case \".yaml\":\n        case \".yml\":\n            return loadYAMLConfigFile(filePath);\n\n        default:\n            return loadLegacyConfigFile(filePath);\n    }\n}\n\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n    /* istanbul ignore next */\n    if (debug.enabled) {\n        let nameAndVersion = null;\n\n        try {\n            const packageJsonPath = ModuleResolver.resolve(\n                `${request}/package.json`,\n                relativeTo\n            );\n            const { version = \"unknown\" } = require(packageJsonPath);\n\n            nameAndVersion = `${request}@${version}`;\n        } catch (error) {\n            debug(\"package.json was not found:\", error.message);\n            nameAndVersion = request;\n        }\n\n        debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n    }\n}\n\n/**\n * Create a new context with default values.\n * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.\n * @param {\"config\" | \"ignore\" | \"implicit-processor\" | undefined} providedType The type of the current configuration. Default is `\"config\"`.\n * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.\n * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.\n * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.\n * @returns {ConfigArrayFactoryLoadingContext} The created context.\n */\nfunction createContext(\n    { cwd, resolvePluginsRelativeTo },\n    providedType,\n    providedName,\n    providedFilePath,\n    providedMatchBasePath\n) {\n    const filePath = providedFilePath\n        ? path.resolve(cwd, providedFilePath)\n        : \"\";\n    const matchBasePath =\n        (providedMatchBasePath && path.resolve(cwd, providedMatchBasePath)) ||\n        (filePath && path.dirname(filePath)) ||\n        cwd;\n    const name =\n        providedName ||\n        (filePath && path.relative(cwd, filePath)) ||\n        \"\";\n    const pluginBasePath =\n        resolvePluginsRelativeTo ||\n        (filePath && path.dirname(filePath)) ||\n        cwd;\n    const type = providedType || \"config\";\n\n    return { filePath, matchBasePath, name, pluginBasePath, type };\n}\n\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\nfunction normalizePlugin(plugin) {\n\n    // first check the cache\n    let normalizedPlugin = normalizedPlugins.get(plugin);\n\n    if (normalizedPlugin) {\n        return normalizedPlugin;\n    }\n\n    normalizedPlugin = {\n        configs: plugin.configs || {},\n        environments: plugin.environments || {},\n        processors: plugin.processors || {},\n        rules: plugin.rules || {}\n    };\n\n    // save the reference for later\n    normalizedPlugins.set(plugin, normalizedPlugin);\n\n    return normalizedPlugin;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\nclass ConfigArrayFactory {\n\n    /**\n     * Initialize this instance.\n     * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n     */\n    constructor({\n        additionalPluginPool = new Map(),\n        cwd = process.cwd(),\n        resolvePluginsRelativeTo,\n        builtInRules,\n        resolver = ModuleResolver,\n        eslintAllPath,\n        getEslintAllConfig,\n        eslintRecommendedPath,\n        getEslintRecommendedConfig\n    } = {}) {\n        internalSlotsMap.set(this, {\n            additionalPluginPool,\n            cwd,\n            resolvePluginsRelativeTo:\n                resolvePluginsRelativeTo &&\n                path.resolve(cwd, resolvePluginsRelativeTo),\n            builtInRules,\n            resolver,\n            eslintAllPath,\n            getEslintAllConfig,\n            eslintRecommendedPath,\n            getEslintRecommendedConfig\n        });\n    }\n\n    /**\n     * Create `ConfigArray` instance from a config data.\n     * @param {ConfigData|null} configData The config data to create.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.filePath] The path to this config data.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config.\n     */\n    create(configData, { basePath, filePath, name } = {}) {\n        if (!configData) {\n            return new ConfigArray();\n        }\n\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(slots, \"config\", name, filePath, basePath);\n        const elements = this._normalizeConfigData(configData, ctx);\n\n        return new ConfigArray(...elements);\n    }\n\n    /**\n     * Load a config file.\n     * @param {string} filePath The path to a config file.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config.\n     */\n    loadFile(filePath, { basePath, name } = {}) {\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(slots, \"config\", name, filePath, basePath);\n\n        return new ConfigArray(...this._loadConfigData(ctx));\n    }\n\n    /**\n     * Load the config file on a given directory if exists.\n     * @param {string} directoryPath The path to a directory.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadInDirectory(directoryPath, { basePath, name } = {}) {\n        const slots = internalSlotsMap.get(this);\n\n        for (const filename of configFilenames) {\n            const ctx = createContext(\n                slots,\n                \"config\",\n                name,\n                path.join(directoryPath, filename),\n                basePath\n            );\n\n            if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {\n                let configData;\n\n                try {\n                    configData = loadConfigFile(ctx.filePath);\n                } catch (error) {\n                    if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n                        throw error;\n                    }\n                }\n\n                if (configData) {\n                    debug(`Config file found: ${ctx.filePath}`);\n                    return new ConfigArray(\n                        ...this._normalizeConfigData(configData, ctx)\n                    );\n                }\n            }\n        }\n\n        debug(`Config file not found on ${directoryPath}`);\n        return new ConfigArray();\n    }\n\n    /**\n     * Check if a config file on a given directory exists or not.\n     * @param {string} directoryPath The path to a directory.\n     * @returns {string | null} The path to the found config file. If not found then null.\n     */\n    static getPathToConfigFileInDirectory(directoryPath) {\n        for (const filename of configFilenames) {\n            const filePath = path.join(directoryPath, filename);\n\n            if (fs.existsSync(filePath)) {\n                if (filename === \"package.json\") {\n                    try {\n                        loadPackageJSONConfigFile(filePath);\n                        return filePath;\n                    } catch { /* ignore */ }\n                } else {\n                    return filePath;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Load `.eslintignore` file.\n     * @param {string} filePath The path to a `.eslintignore` file to load.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadESLintIgnore(filePath) {\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(\n            slots,\n            \"ignore\",\n            void 0,\n            filePath,\n            slots.cwd\n        );\n        const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);\n\n        return new ConfigArray(\n            ...this._normalizeESLintIgnoreData(ignorePatterns, ctx)\n        );\n    }\n\n    /**\n     * Load `.eslintignore` file in the current working directory.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadDefaultESLintIgnore() {\n        const slots = internalSlotsMap.get(this);\n        const eslintIgnorePath = path.resolve(slots.cwd, \".eslintignore\");\n        const packageJsonPath = path.resolve(slots.cwd, \"package.json\");\n\n        if (fs.existsSync(eslintIgnorePath)) {\n            return this.loadESLintIgnore(eslintIgnorePath);\n        }\n        if (fs.existsSync(packageJsonPath)) {\n            const data = loadJSONConfigFile(packageJsonPath);\n\n            if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n                if (!Array.isArray(data.eslintIgnore)) {\n                    throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n                }\n                const ctx = createContext(\n                    slots,\n                    \"ignore\",\n                    \"eslintIgnore in package.json\",\n                    packageJsonPath,\n                    slots.cwd\n                );\n\n                return new ConfigArray(\n                    ...this._normalizeESLintIgnoreData(data.eslintIgnore, ctx)\n                );\n            }\n        }\n\n        return new ConfigArray();\n    }\n\n    /**\n     * Load a given config file.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n     * @private\n     */\n    _loadConfigData(ctx) {\n        return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);\n    }\n\n    /**\n     * Normalize a given `.eslintignore` data to config array elements.\n     * @param {string[]} ignorePatterns The patterns to ignore files.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeESLintIgnoreData(ignorePatterns, ctx) {\n        const elements = this._normalizeObjectConfigData(\n            { ignorePatterns },\n            ctx\n        );\n\n        // Set `ignorePattern.loose` flag for backward compatibility.\n        for (const element of elements) {\n            if (element.ignorePattern) {\n                element.ignorePattern.loose = true;\n            }\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _normalizeConfigData(configData, ctx) {\n        const validator = new ConfigValidator();\n\n        validator.validateConfigSchema(configData, ctx.name || ctx.filePath);\n        return this._normalizeObjectConfigData(configData, ctx);\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigData(configData, ctx) {\n        const { files, excludedFiles, ...configBody } = configData;\n        const criteria = OverrideTester.create(\n            files,\n            excludedFiles,\n            ctx.matchBasePath\n        );\n        const elements = this._normalizeObjectConfigDataBody(configBody, ctx);\n\n        // Apply the criteria to every element.\n        for (const element of elements) {\n\n            /*\n             * Merge the criteria.\n             * This is for the `overrides` entries that came from the\n             * configurations of `overrides[].extends`.\n             */\n            element.criteria = OverrideTester.and(criteria, element.criteria);\n\n            /*\n             * Remove `root` property to ignore `root` settings which came from\n             * `extends` in `overrides`.\n             */\n            if (element.criteria) {\n                element.root = void 0;\n            }\n\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigDataBody(\n        {\n            env,\n            extends: extend,\n            globals,\n            ignorePatterns,\n            noInlineConfig,\n            parser: parserName,\n            parserOptions,\n            plugins: pluginList,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings,\n            overrides: overrideList = []\n        },\n        ctx\n    ) {\n        const extendList = Array.isArray(extend) ? extend : [extend];\n        const ignorePattern = ignorePatterns && new IgnorePattern(\n            Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns],\n            ctx.matchBasePath\n        );\n\n        // Flatten `extends`.\n        for (const extendName of extendList.filter(Boolean)) {\n            yield* this._loadExtends(extendName, ctx);\n        }\n\n        // Load parser & plugins.\n        const parser = parserName && this._loadParser(parserName, ctx);\n        const plugins = pluginList && this._loadPlugins(pluginList, ctx);\n\n        // Yield pseudo config data for file extension processors.\n        if (plugins) {\n            yield* this._takeFileExtensionProcessors(plugins, ctx);\n        }\n\n        // Yield the config data except `extends` and `overrides`.\n        yield {\n\n            // Debug information.\n            type: ctx.type,\n            name: ctx.name,\n            filePath: ctx.filePath,\n\n            // Config data.\n            criteria: null,\n            env,\n            globals,\n            ignorePattern,\n            noInlineConfig,\n            parser,\n            parserOptions,\n            plugins,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings\n        };\n\n        // Flatten `overries`.\n        for (let i = 0; i < overrideList.length; ++i) {\n            yield* this._normalizeObjectConfigData(\n                overrideList[i],\n                { ...ctx, name: `${ctx.name}#overrides[${i}]` }\n            );\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtends(extendName, ctx) {\n        debug(\"Loading {extends:%j} relative to %s\", extendName, ctx.filePath);\n        try {\n            if (extendName.startsWith(\"eslint:\")) {\n                return this._loadExtendedBuiltInConfig(extendName, ctx);\n            }\n            if (extendName.startsWith(\"plugin:\")) {\n                return this._loadExtendedPluginConfig(extendName, ctx);\n            }\n            return this._loadExtendedShareableConfig(extendName, ctx);\n        } catch (error) {\n            error.message += `\\nReferenced from: ${ctx.filePath || ctx.name}`;\n            throw error;\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedBuiltInConfig(extendName, ctx) {\n        const {\n            eslintAllPath,\n            getEslintAllConfig,\n            eslintRecommendedPath,\n            getEslintRecommendedConfig\n        } = internalSlotsMap.get(this);\n\n        if (extendName === \"eslint:recommended\") {\n            const name = `${ctx.name}  ${extendName}`;\n\n            if (getEslintRecommendedConfig) {\n                if (typeof getEslintRecommendedConfig !== \"function\") {\n                    throw new Error(`getEslintRecommendedConfig must be a function instead of '${getEslintRecommendedConfig}'`);\n                }\n                return this._normalizeConfigData(getEslintRecommendedConfig(), { ...ctx, name, filePath: \"\" });\n            }\n            return this._loadConfigData({\n                ...ctx,\n                name,\n                filePath: eslintRecommendedPath\n            });\n        }\n        if (extendName === \"eslint:all\") {\n            const name = `${ctx.name}  ${extendName}`;\n\n            if (getEslintAllConfig) {\n                if (typeof getEslintAllConfig !== \"function\") {\n                    throw new Error(`getEslintAllConfig must be a function instead of '${getEslintAllConfig}'`);\n                }\n                return this._normalizeConfigData(getEslintAllConfig(), { ...ctx, name, filePath: \"\" });\n            }\n            return this._loadConfigData({\n                ...ctx,\n                name,\n                filePath: eslintAllPath\n            });\n        }\n\n        throw configInvalidError(extendName, ctx.name, \"extend-config-missing\");\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedPluginConfig(extendName, ctx) {\n        const slashIndex = extendName.lastIndexOf(\"/\");\n\n        if (slashIndex === -1) {\n            throw configInvalidError(extendName, ctx.filePath, \"plugin-invalid\");\n        }\n\n        const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n        const configName = extendName.slice(slashIndex + 1);\n\n        if (isFilePath(pluginName)) {\n            throw new Error(\"'extends' cannot use a file path for plugins.\");\n        }\n\n        const plugin = this._loadPlugin(pluginName, ctx);\n        const configData =\n            plugin.definition &&\n            plugin.definition.configs[configName];\n\n        if (configData) {\n            return this._normalizeConfigData(configData, {\n                ...ctx,\n                filePath: plugin.filePath || ctx.filePath,\n                name: `${ctx.name}  plugin:${plugin.id}/${configName}`\n            });\n        }\n\n        throw plugin.error || configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedShareableConfig(extendName, ctx) {\n        const { cwd, resolver } = internalSlotsMap.get(this);\n        const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n        let request;\n\n        if (isFilePath(extendName)) {\n            request = extendName;\n        } else if (extendName.startsWith(\".\")) {\n            request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n        } else {\n            request = naming.normalizePackageName(\n                extendName,\n                \"eslint-config\"\n            );\n        }\n\n        let filePath;\n\n        try {\n            filePath = resolver.resolve(request, relativeTo);\n        } catch (error) {\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                throw configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n            }\n            throw error;\n        }\n\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        return this._loadConfigData({\n            ...ctx,\n            filePath,\n            name: `${ctx.name}  ${request}`\n        });\n    }\n\n    /**\n     * Load given plugins.\n     * @param {string[]} names The plugin names to load.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {Record<string,DependentPlugin>} The loaded parser.\n     * @private\n     */\n    _loadPlugins(names, ctx) {\n        return names.reduce((map, name) => {\n            if (isFilePath(name)) {\n                throw new Error(\"Plugins array cannot includes file paths.\");\n            }\n            const plugin = this._loadPlugin(name, ctx);\n\n            map[plugin.id] = plugin;\n\n            return map;\n        }, {});\n    }\n\n    /**\n     * Load a given parser.\n     * @param {string} nameOrPath The package name or the path to a parser file.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {DependentParser} The loaded parser.\n     */\n    _loadParser(nameOrPath, ctx) {\n        debug(\"Loading parser %j from %s\", nameOrPath, ctx.filePath);\n\n        const { cwd, resolver } = internalSlotsMap.get(this);\n        const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n\n        try {\n            const filePath = resolver.resolve(nameOrPath, relativeTo);\n\n            writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n\n            return new ConfigDependency({\n                definition: require(filePath),\n                filePath,\n                id: nameOrPath,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        } catch (error) {\n\n            // If the parser name is \"espree\", load the espree of ESLint.\n            if (nameOrPath === \"espree\") {\n                debug(\"Fallback espree.\");\n                return new ConfigDependency({\n                    definition: require(\"espree\"),\n                    filePath: require.resolve(\"espree\"),\n                    id: nameOrPath,\n                    importerName: ctx.name,\n                    importerPath: ctx.filePath\n                });\n            }\n\n            debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, ctx.name);\n            error.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error.message}`;\n\n            return new ConfigDependency({\n                error,\n                id: nameOrPath,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n    }\n\n    /**\n     * Load a given plugin.\n     * @param {string} name The plugin name to load.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {DependentPlugin} The loaded plugin.\n     * @private\n     */\n    _loadPlugin(name, ctx) {\n        debug(\"Loading plugin %j from %s\", name, ctx.filePath);\n\n        const { additionalPluginPool, resolver } = internalSlotsMap.get(this);\n        const request = naming.normalizePackageName(name, \"eslint-plugin\");\n        const id = naming.getShorthandName(request, \"eslint-plugin\");\n        const relativeTo = path.join(ctx.pluginBasePath, \"__placeholder__.js\");\n\n        if (name.match(/\\s+/u)) {\n            const error = Object.assign(\n                new Error(`Whitespace found in plugin name '${name}'`),\n                {\n                    messageTemplate: \"whitespace-found\",\n                    messageData: { pluginName: request }\n                }\n            );\n\n            return new ConfigDependency({\n                error,\n                id,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n\n        // Check for additional pool.\n        const plugin =\n            additionalPluginPool.get(request) ||\n            additionalPluginPool.get(id);\n\n        if (plugin) {\n            return new ConfigDependency({\n                definition: normalizePlugin(plugin),\n                filePath: \"\", // It's unknown where the plugin came from.\n                id,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n\n        let filePath;\n        let error;\n\n        try {\n            filePath = resolver.resolve(request, relativeTo);\n        } catch (resolveError) {\n            error = resolveError;\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                error.messageTemplate = \"plugin-missing\";\n                error.messageData = {\n                    pluginName: request,\n                    resolvePluginsRelativeTo: ctx.pluginBasePath,\n                    importerName: ctx.name\n                };\n            }\n        }\n\n        if (filePath) {\n            try {\n                writeDebugLogForLoading(request, relativeTo, filePath);\n\n                const startTime = Date.now();\n                const pluginDefinition = require(filePath);\n\n                debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n\n                return new ConfigDependency({\n                    definition: normalizePlugin(pluginDefinition),\n                    filePath,\n                    id,\n                    importerName: ctx.name,\n                    importerPath: ctx.filePath\n                });\n            } catch (loadError) {\n                error = loadError;\n            }\n        }\n\n        debug(\"Failed to load plugin '%s' declared in '%s'.\", name, ctx.name);\n        error.message = `Failed to load plugin '${name}' declared in '${ctx.name}': ${error.message}`;\n        return new ConfigDependency({\n            error,\n            id,\n            importerName: ctx.name,\n            importerPath: ctx.filePath\n        });\n    }\n\n    /**\n     * Take file expression processors as config array elements.\n     * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n     * @private\n     */\n    *_takeFileExtensionProcessors(plugins, ctx) {\n        for (const pluginId of Object.keys(plugins)) {\n            const processors =\n                plugins[pluginId] &&\n                plugins[pluginId].definition &&\n                plugins[pluginId].definition.processors;\n\n            if (!processors) {\n                continue;\n            }\n\n            for (const processorId of Object.keys(processors)) {\n                if (processorId.startsWith(\".\")) {\n                    yield* this._normalizeObjectConfigData(\n                        {\n                            files: [`*${processorId}`],\n                            processor: `${pluginId}/${processorId}`\n                        },\n                        {\n                            ...ctx,\n                            type: \"implicit-processor\",\n                            name: `${ctx.name}#processors[\"${pluginId}/${processorId}\"]`\n                        }\n                    );\n                }\n            }\n        }\n    }\n}\n\nexport { ConfigArrayFactory, createContext };\n","/**\n * @fileoverview `CascadingConfigArrayFactory` class.\n *\n * `CascadingConfigArrayFactory` class has a responsibility:\n *\n * 1. Handles cascading of config files.\n *\n * It provides two methods:\n *\n * - `getConfigArrayForFile(filePath)`\n *     Get the corresponded configuration of a given file. This method doesn't\n *     throw even if the given file didn't exist.\n * - `clearCache()`\n *     Clear the internal cache. You have to call this method when\n *     `additionalPluginPool` was updated if `baseConfig` or `cliConfig` depends\n *     on the additional plugins. (`CLIEngine#addPlugin()` method calls this.)\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport debugOrig from \"debug\";\nimport os from \"os\";\nimport path from \"path\";\n\nimport { ConfigArrayFactory } from \"./config-array-factory.js\";\nimport {\n    ConfigArray,\n    ConfigDependency,\n    IgnorePattern\n} from \"./config-array/index.js\";\nimport ConfigValidator from \"./shared/config-validator.js\";\nimport { emitDeprecationWarning } from \"./shared/deprecation-warnings.js\";\n\nconst debug = debugOrig(\"eslintrc:cascading-config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n/** @typedef {ReturnType<ConfigArrayFactory[\"create\"]>} ConfigArray */\n\n/**\n * @typedef {Object} CascadingConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {ConfigData} [baseConfig] The config by `baseConfig` option.\n * @property {ConfigData} [cliConfig] The config by CLI options (`--env`, `--global`, `--ignore-pattern`, `--parser`, `--parser-options`, `--plugin`, and `--rule`). CLI options overwrite the setting in config files.\n * @property {string} [cwd] The base directory to start lookup.\n * @property {string} [ignorePath] The path to the alternative file of `.eslintignore`.\n * @property {string[]} [rulePaths] The value of `--rulesdir` option.\n * @property {string} [specificConfigPath] The value of `--config` option.\n * @property {boolean} [useEslintrc] if `false` then it doesn't load config files.\n * @property {Function} loadRules The function to use to load rules.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} CascadingConfigArrayFactoryInternalSlots\n * @property {ConfigArray} baseConfigArray The config array of `baseConfig` option.\n * @property {ConfigData} baseConfigData The config data of `baseConfig` option. This is used to reset `baseConfigArray`.\n * @property {ConfigArray} cliConfigArray The config array of CLI options.\n * @property {ConfigData} cliConfigData The config data of CLI options. This is used to reset `cliConfigArray`.\n * @property {ConfigArrayFactory} configArrayFactory The factory for config arrays.\n * @property {Map<string, ConfigArray>} configCache The cache from directory paths to config arrays.\n * @property {string} cwd The base directory to start lookup.\n * @property {WeakMap<ConfigArray, ConfigArray>} finalizeCache The cache from config arrays to finalized config arrays.\n * @property {string} [ignorePath] The path to the alternative file of `.eslintignore`.\n * @property {string[]|null} rulePaths The value of `--rulesdir` option. This is used to reset `baseConfigArray`.\n * @property {string|null} specificConfigPath The value of `--config` option. This is used to reset `cliConfigArray`.\n * @property {boolean} useEslintrc if `false` then it doesn't load config files.\n * @property {Function} loadRules The function to use to load rules.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/** @type {WeakMap<CascadingConfigArrayFactory, CascadingConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Create the config array from `baseConfig` and `rulePaths`.\n * @param {CascadingConfigArrayFactoryInternalSlots} slots The slots.\n * @returns {ConfigArray} The config array of the base configs.\n */\nfunction createBaseConfigArray({\n    configArrayFactory,\n    baseConfigData,\n    rulePaths,\n    cwd,\n    loadRules\n}) {\n    const baseConfigArray = configArrayFactory.create(\n        baseConfigData,\n        { name: \"BaseConfig\" }\n    );\n\n    /*\n     * Create the config array element for the default ignore patterns.\n     * This element has `ignorePattern` property that ignores the default\n     * patterns in the current working directory.\n     */\n    baseConfigArray.unshift(configArrayFactory.create(\n        { ignorePatterns: IgnorePattern.DefaultPatterns },\n        { name: \"DefaultIgnorePattern\" }\n    )[0]);\n\n    /*\n     * Load rules `--rulesdir` option as a pseudo plugin.\n     * Use a pseudo plugin to define rules of `--rulesdir`, so we can validate\n     * the rule's options with only information in the config array.\n     */\n    if (rulePaths && rulePaths.length > 0) {\n        baseConfigArray.push({\n            type: \"config\",\n            name: \"--rulesdir\",\n            filePath: \"\",\n            plugins: {\n                \"\": new ConfigDependency({\n                    definition: {\n                        rules: rulePaths.reduce(\n                            (map, rulesPath) => Object.assign(\n                                map,\n                                loadRules(rulesPath, cwd)\n                            ),\n                            {}\n                        )\n                    },\n                    filePath: \"\",\n                    id: \"\",\n                    importerName: \"--rulesdir\",\n                    importerPath: \"\"\n                })\n            }\n        });\n    }\n\n    return baseConfigArray;\n}\n\n/**\n * Create the config array from CLI options.\n * @param {CascadingConfigArrayFactoryInternalSlots} slots The slots.\n * @returns {ConfigArray} The config array of the base configs.\n */\nfunction createCLIConfigArray({\n    cliConfigData,\n    configArrayFactory,\n    cwd,\n    ignorePath,\n    specificConfigPath\n}) {\n    const cliConfigArray = configArrayFactory.create(\n        cliConfigData,\n        { name: \"CLIOptions\" }\n    );\n\n    cliConfigArray.unshift(\n        ...(ignorePath\n            ? configArrayFactory.loadESLintIgnore(ignorePath)\n            : configArrayFactory.loadDefaultESLintIgnore())\n    );\n\n    if (specificConfigPath) {\n        cliConfigArray.unshift(\n            ...configArrayFactory.loadFile(\n                specificConfigPath,\n                { name: \"--config\", basePath: cwd }\n            )\n        );\n    }\n\n    return cliConfigArray;\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass ConfigurationNotFoundError extends Error {\n\n    // eslint-disable-next-line jsdoc/require-description\n    /**\n     * @param {string} directoryPath The directory path.\n     */\n    constructor(directoryPath) {\n        super(`No ESLint configuration found in ${directoryPath}.`);\n        this.messageTemplate = \"no-config-found\";\n        this.messageData = { directoryPath };\n    }\n}\n\n/**\n * This class provides the functionality that enumerates every file which is\n * matched by given glob patterns and that configuration.\n */\nclass CascadingConfigArrayFactory {\n\n    /**\n     * Initialize this enumerator.\n     * @param {CascadingConfigArrayFactoryOptions} options The options.\n     */\n    constructor({\n        additionalPluginPool = new Map(),\n        baseConfig: baseConfigData = null,\n        cliConfig: cliConfigData = null,\n        cwd = process.cwd(),